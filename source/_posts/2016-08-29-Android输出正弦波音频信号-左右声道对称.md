---
title: Android输出正弦波音频信号(左右声道对称)
date: 2016-08-29 15:01:34
categories:
tags: [Android,正弦波]
---

---
转载请说明出处！
作者：[kqw攻城狮](http://kongqw.github.io/about/index.html)
出处：[个人站](http://kongqw.com/2016/08/29/2016-08-29-Android%E8%BE%93%E5%87%BA%E6%AD%A3%E5%BC%A6%E6%B3%A2%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7-%E5%B7%A6%E5%8F%B3%E5%A3%B0%E9%81%93%E5%AF%B9%E7%A7%B0/) | [CSDN](http://blog.csdn.net/q4878802/article/details/52353727)

---

需求：左右声道分别输出不同的音频数据，波形要是一个正弦波，左右声道还要对称！
对硬件不是很了解，说是要通过音波避障。

# 效果图

![效果图](http://img.blog.csdn.net/20160829154617837)

之前已经介绍了如何在左右声道输出不同的音频数据。
那么这里主要介绍如何模拟出波形是正弦波的音频数据。

# 模拟正弦波

``` java
/**
 * 模拟正弦波音频数据
 * @param isLeft 左右声道
 * @return 音频数据
 */
private short[] initData(boolean isLeft) {
    double phase = 0.0;
    int amp = 10000;
    short[] data = new short[bufferSize];

    double phaseIncrement = (2 * Math.PI * mFrequency) / mSampleRateInHz;

    for (int i = 0; i < bufferSize; i++) {
        if (isLeft) {
            data[i] = (short) (amp * Math.sin(phase));
        } else {
            data[i] = (short) (-amp * Math.sin(phase));
        }
        phase += phaseIncrement;
        Log.i(TAG, "initData: isLeft = " + isLeft + "  buffer[" + i + "] = " + data[i]);
    }
    return data;
}
```

主要参数

* mFrequency：频率
* mSampleRateInHz：采样率

``` java
// 单声道
private int mChannelConfig = AudioFormat.CHANNEL_OUT_MONO;
// 频率
private int mFrequency = 19000;
// 采样率
private int mSampleRateInHz = 44100;
```

# 播放音频的线程封装

``` java
package kong.qingwei.myapplication;

import android.annotation.TargetApi;
import android.media.AudioFormat;
import android.media.AudioManager;
import android.media.AudioTrack;
import android.os.Build;
import android.util.Log;

/**
 * Created by kqw on 2016/8/29.
 * 播放音乐的线程
 */
public class ChannelThread extends Thread {

    private static final String TAG = "ChannelThread";
    private AudioTrack mAudioTrack;

    private short[] mData;

    /**
     * 构造方法
     *
     * @param channelConfig  声道
     * @param sampleRateInHz 采样率
     * @param data           音频数据
     * @param bufferSize     缓存大小
     * @param isLeft         左右声道
     */
    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public ChannelThread(int channelConfig, int sampleRateInHz, short[] data, int bufferSize, boolean isLeft) {
        mData = data;

        mAudioTrack = new AudioTrack(
                AudioManager.STREAM_MUSIC,
                sampleRateInHz,
                channelConfig,
                AudioFormat.ENCODING_PCM_16BIT,
                bufferSize,
                AudioTrack.MODE_STREAM);

        if (isLeft) {
            mAudioTrack.setStereoVolume(AudioTrack.getMaxVolume(), 0);
        } else {
            mAudioTrack.setStereoVolume(0, AudioTrack.getMaxVolume());
        }
    }

    @Override
    public void run() {
        super.run();
        try {
            if (null != mAudioTrack) {
                mAudioTrack.play();
                while (AudioTrack.PLAYSTATE_STOPPED != mAudioTrack.getPlayState()) {
                    mAudioTrack.write(mData, 0, mData.length);
                }
            }
            Log.i(TAG, "run: End");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 释放AudioTrack
     */
    public void releaseAudioTrack() {
        if (null != mAudioTrack) {
            mAudioTrack.stop();
            mAudioTrack.release();
            mAudioTrack = null;
        }
    }
}
```

# 播放

``` java
mLeftChannelThread = new ChannelThread(mChannelConfig, mSampleRateInHz, mDataLeft, bufferSize, true);
mRightChannelThread = new ChannelThread(mChannelConfig, mSampleRateInHz, mDataRight, bufferSize, false);

mLeftChannelThread.start();
mRightChannelThread.start();
```

# 停止
``` java
if (null != mLeftChannelThread) {
    mLeftChannelThread.releaseAudioTrack();
    mLeftChannelThread = null;
}
if (null != mRightChannelThread) {
    mRightChannelThread.releaseAudioTrack();
    mRightChannelThread = null;
}
```

# 不足

这里介绍的是在程序中模拟出一个波形满足正弦波的音频数据，还有一种方式，可以事先准备好一个这样的音频文件，直接播放就可以了。

在程序中模拟音频数据有一个缺点，就是不能保证两个线程完完全全的同步，即便是同时开启两个线程也有一先一后，在频率很高的时候，难免会有一点误差！像下面这样：

![误差图](http://img.blog.csdn.net/20160829154737304)

另外，这个波形和硬件有很大关系，越是低配设备，误差可能会越大，相同的趋势，但是波动的幅度会比较大（线很粗），可能和设备本身的噪音有关系。