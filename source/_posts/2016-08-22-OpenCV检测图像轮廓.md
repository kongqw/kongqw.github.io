---
title: OpenCV检测图像轮廓
date: 2016-08-22 11:35:23
categories: OpenCV
tags: [OpenCV]
---

---
转载请说明出处！
作者：[kqw攻城狮](http://kongqw.github.io/about/index.html)
出处：[个人站](http://kongqw.github.io) | [CSDN](http://blog.csdn.net/q4878802/)

---

**轮廓**只不过是图像中连接的曲线，或者图像中连通部分的边界，轮廓通常以图像中的边缘来计算，但是，边缘和轮廓的区别在于轮廓是闭合的，而边缘可以是任意的。边缘的概念局限于点及其邻域像素，轮廓将目标作为整体进行处理。
# 效果图

![效果图](http://img.blog.csdn.net/20160822114857928)

![原图](http://img.blog.csdn.net/20160822114912492)

# 源码

[KqwOpenCVFeaturesDemo](https://github.com/kongqw/KqwOpenCVFeaturesDemo)

# 步骤

 1. 将图像置灰
 2. 使用Canny边缘检测检测出图像的边缘
 3. 调用`Imgproc.findContours()`方法检测图像轮廓
 4. 在新的图像上画出轮廓

# 封装

``` java
/**
 * 找出轮廓
 *
 * @param bitmap 要检测的图片
 */
public void findContours(Bitmap bitmap) {
    if (null != mSubscriber)
        Observable
                .just(bitmap)
                // 检测边缘
                .map(new Func1<Bitmap, Mat>() {
                    @Override
                    public Mat call(Bitmap bitmap) {
                        Mat grayMat = new Mat();
                        Mat cannyEdges = new Mat();

                        // Bitmap转为Mat
                        Mat src = new Mat(bitmap.getHeight(), bitmap.getWidth(), CvType.CV_8UC4);
                        Utils.bitmapToMat(bitmap, src);

                        // 原图置灰
                        Imgproc.cvtColor(src, grayMat, Imgproc.COLOR_BGR2GRAY);
                        // Canny边缘检测器检测图像边缘
                        Imgproc.Canny(grayMat, cannyEdges, 10, 100);

                        return cannyEdges;
                    }
                })
                // 找出轮廓
                .map(new Func1<Mat, Bitmap>() {

                    @Override
                    public Bitmap call(Mat cannyEdges) {

                        Mat hierarchy = new Mat();
                        // 保存轮廓
                        ArrayList<MatOfPoint> contourList = new ArrayList<>();

                        // 检测轮廓
                        Imgproc.findContours(cannyEdges, contourList, hierarchy, Imgproc.RETR_LIST, Imgproc.CHAIN_APPROX_SIMPLE);

                        // 画出轮廓
                        Mat contours = new Mat();
                        contours.create(cannyEdges.rows(), cannyEdges.cols(), CvType.CV_8UC3);
                        Random r = new Random();
                        for (int i = 0; i < contourList.size(); i++) {
                            Imgproc.drawContours(contours, contourList, i, new Scalar(r.nextInt(255), r.nextInt(255), r.nextInt(255), -1));
                        }

                        // Mat转Bitmap
                        Bitmap processedImage = Bitmap.createBitmap(contours.cols(), contours.rows(), Bitmap.Config.ARGB_8888);
                        Utils.matToBitmap(contours, processedImage);

                        return processedImage;
                    }
                })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(mSubscriber);
}
```

# 使用

``` java
// 图片特征提取的工具类
mFeaturesUtil = new FeaturesUtil(new Subscriber<Bitmap>() {
    @Override
    public void onCompleted() {
        // 图片处理完成
        dismissProgressDialog();
    }

    @Override
    public void onError(Throwable e) {
        // 图片处理异常
        dismissProgressDialog();
    }

    @Override
    public void onNext(Bitmap bitmap) {
        // 获取到处理后的图片
        mImageView.setImageBitmap(bitmap);
    }
});

// 找出轮廓
mFeaturesUtil.findContours(mSelectImage);
```