---
title: OpenCV实现图像阈值化
date: 2016-08-18 18:59:50
categories: OpenCV
tags: [OpenCV]
---

---
转载请说明出处！
作者：[kqw攻城狮](http://kongqw.github.io/about/index.html)
出处：[个人站](http://kongqw.github.io) | [CSDN](http://blog.csdn.net/q4878802/)

---

# 效果图

![效果图](http://img.blog.csdn.net/20160818193140495)

![效果图](http://img.blog.csdn.net/20160818193148727)

# 源码

[KqwOpenCVBlurDemo](https://github.com/kongqw/KqwOpenCVBlurDemo)

**阈值化**是一种将我们想要在图像中分析的区域分割出来的方法。
我们把每个像素值都与一个预设的阈值做比较，再根据比较的结果调整像素值。

类似这样

``` java
Imgproc.threshold(src, src, 100, 255, Imgproc.THRESH_BINARY);
```

其中100是阈值，255是最大值（纯白色的值）。

# 常量

|名称           |   常量                  |
|--------------|-------------------------|
|二值阈值化     |Imgproc.THRESH_BINARY    |
|阈值化到零     |Imgproc.THRESH_TOZERO    |
|截断阈值化     |Imgproc.THRESH_TRUNC     |
|反转二值阈值化  |Imgproc.THRESH_BINARY_INV|
|反转阈值化到零  |Imgproc.THRESH_TOZERO_INV|


# 自适应阈值

上述的阈值化是全局性的，我们也可以根据邻域像素为任意像素计算阈值。

自适应阈值用到的3个参数

1. **自适应方法**

	* Imgproc.ADAPTIVE_THRESH_MEAN_C：阈值是邻域像素的值
	* Imgproc.ADAPTIVE_THRESH_GAUSSIAN_C：阈值是领域像素的加权和，权重来自高斯核

2. **块尺寸**：邻域的大小	
3. **常量C**：从对每个像素计算得到的均值或加权均值减去的常量



图像置灰

``` java                            
Imgproc.cvtColor(src, src, Imgproc.COLOR_BGR2GRAY);
```

自适应阈值化

``` java                            
Imgproc.adaptiveThreshold(src, src, 255, Imgproc.ADAPTIVE_THRESH_MEAN_C, Imgproc.THRESH_BINARY, 3, 0);
```

# 封装

这里我用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。

``` java
/**
 * 自适应阈值
 *
 * @param bitmap 要处理的图片
 */
public void adaptiveThreshold(Bitmap bitmap) {
    // 使用RxJava处理图片
    if (null != mSubscriber)
        Observable
                .just(bitmap)
                .map(new Func1<Bitmap, Bitmap>() {

                    @Override
                    public Bitmap call(Bitmap bitmap) {
                        // Bitmap转为Mat
                        Mat src = new Mat(bitmap.getHeight(), bitmap.getWidth(), CvType.CV_8UC4);
                        Utils.bitmapToMat(bitmap, src);

                        // 图像置灰
                        Imgproc.cvtColor(src, src, Imgproc.COLOR_BGR2GRAY);
                        // 自适应阈值化
                        Imgproc.adaptiveThreshold(src, src, 255, Imgproc.ADAPTIVE_THRESH_MEAN_C, Imgproc.THRESH_BINARY, 3, 0);

                        // 二值阈值化
                        // Imgproc.threshold(src,src,100,255,Imgproc.THRESH_BINARY);
                        // 阈值化到零
                        // Imgproc.threshold(src,src,100,255,Imgproc.THRESH_TOZERO);
                        // 截断阈值化
                        // Imgproc.threshold(src,src,100,255,Imgproc.THRESH_TRUNC);
                        // 反转二值阈值化
                        // Imgproc.threshold(src,src,100,255,Imgproc.THRESH_BINARY_INV);
                        // 反转阈值化到零
                        // Imgproc.threshold(src,src,100,255,Imgproc.THRESH_TOZERO_INV);

                        // Mat转Bitmap
                        Bitmap processedImage = Bitmap.createBitmap(src.cols(), src.rows(), Bitmap.Config.ARGB_8888);
                        Utils.matToBitmap(src, processedImage);

                        return processedImage;
                    }
                })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(mSubscriber);
}
```


# 调用

``` java
// 图片处理的工具类
mBlurUtil = new BlurUtil(new Subscriber<Bitmap>() {
    @Override
    public void onCompleted() {
        // 图片处理完成
        dismissProgressDialog();
    }

    @Override
    public void onError(Throwable e) {
        // 图片处理异常
        dismissProgressDialog();
    }

    @Override
    public void onNext(Bitmap bitmap) {
        // 获取到处理后的图片
        mIvImageProcessed.setImageBitmap(bitmap);
    }
});

// 自适应阈值
mBlurUtil.adaptiveThreshold(mSelectImage);
```











